// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCat3_EncodeDecode(t *testing.T) {
	var typ Cat3
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat3
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat5_EncodeDecode(t *testing.T) {
	var typ Cat5
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat5
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat5Kind_EncodeDecode(t *testing.T) {
	var typ Cat5Kind
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat5Kind
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat6_EncodeDecode(t *testing.T) {
	var typ Cat6
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat6
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat7_EncodeDecode(t *testing.T) {
	var typ Cat7
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat7
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat7ID_EncodeDecode(t *testing.T) {
	var typ Cat7ID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat7ID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCat8_EncodeDecode(t *testing.T) {
	var typ Cat8
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Cat8
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateReq_EncodeDecode(t *testing.T) {
	var typ CreateReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog3_EncodeDecode(t *testing.T) {
	var typ Dog3
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog3
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog5_EncodeDecode(t *testing.T) {
	var typ Dog5
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog5
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog5Kind_EncodeDecode(t *testing.T) {
	var typ Dog5Kind
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog5Kind
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog6_EncodeDecode(t *testing.T) {
	var typ Dog6
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog6
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog7_EncodeDecode(t *testing.T) {
	var typ Dog7
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog7
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog7ID_EncodeDecode(t *testing.T) {
	var typ Dog7ID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog7ID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDog8_EncodeDecode(t *testing.T) {
	var typ Dog8
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Dog8
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet_EncodeDecode(t *testing.T) {
	var typ Pet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet2_EncodeDecode(t *testing.T) {
	var typ Pet2
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet2
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet4_EncodeDecode(t *testing.T) {
	var typ Pet4
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet4
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet5_EncodeDecode(t *testing.T) {
	var typ Pet5
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet5
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet5Sum_EncodeDecode(t *testing.T) {
	var typ Pet5Sum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet5Sum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6_EncodeDecode(t *testing.T) {
	var typ Pet6
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6Cat_EncodeDecode(t *testing.T) {
	var typ Pet6Cat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6Cat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6CatDataKind_EncodeDecode(t *testing.T) {
	var typ Pet6CatDataKind
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6CatDataKind
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6Dog_EncodeDecode(t *testing.T) {
	var typ Pet6Dog
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6Dog
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6DogDataKind_EncodeDecode(t *testing.T) {
	var typ Pet6DogDataKind
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6DogDataKind
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet6Sum_EncodeDecode(t *testing.T) {
	var typ Pet6Sum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet6Sum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet7_EncodeDecode(t *testing.T) {
	var typ Pet7
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet7
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet7Sum_EncodeDecode(t *testing.T) {
	var typ Pet7Sum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet7Sum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet8_EncodeDecode(t *testing.T) {
	var typ Pet8
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet8
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPet8Sum_EncodeDecode(t *testing.T) {
	var typ Pet8Sum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pet8Sum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThePet_EncodeDecode(t *testing.T) {
	var typ ThePet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThePet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
